KV 1.

Правильно писать типы аргументов и указатели на них. Функция обычно проводит какое-то действие. Один или несколько одинаковых действий. 
Лучше называть функции глаголом + существительным, например, sortColors. 
в целом, какие-либо промежуточные расчёты следует помещать в отдельную функцию.

KV 2.

Втраивание функций - способ оптимизации, при котором вызов функции заменяется непосредственно её телом.
Встраивание функций аналогично по сути подстановке из макроса, но в отличие от неё не изменяет исходный 
код и происходит во время компиляции, в то время как макросы изменяют исходный код перед компиляцией.
Встроенные функции работают быстрее, потому что вам не нужно вставлять и извлекать такие вещи из стека, 
как параметры и адрес возврата; однако, это делает ваш двоичный файл немного больше.

KV 3.

Только правые аргументы функции. То есть:
void printValue(int a = 5, int b); // не разрешается
void printValue(int a, int b = 5); // разрешается

KV4.

Перегрузка функции возможно при разных функциях. 
Компилятор может определить сам, какую версию функции следует вызывать на основе аргументов, 
используемых в вызове функции. Фактически, мы можем определить столько перегруженных функций, 
сколько хотим, до тех пор, пока каждая из них будет иметь свои (уникальные) параметры.
Пример: 
int subtract(int a, int b); // целочисленная версия
double subtract(double a, double b); // версия типа с плавающей запятой
int subtract(int a, int b, int c){
    return a - b - c;
}
KV 5.
С помощью std::function.
Пример:
std::function<double(double, double)> addNumbers2{ 
    [](double a, double b) {
      return (a + b);
    }
  };
 
addNumbers2(3, 4);